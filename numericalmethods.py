# -*- coding: utf-8 -*-
"""NumericalMethods.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DUTCwFQBtitApiu7z8mDCzl-Rd7baJ3z
"""

import math
import numpy as np

"""# Bisection Method"""

def bisection_method(func, a, b, tol):

    def f(x):
        f = eval(func)
        return f

    i = 1
    while abs(b-a) > tol:

        # bisection method formula
        c = (a+b)/2

        if f(c) == 0:
            return c

        elif f(c) * f(a) < 0:
            b = c

        elif f(c) * f(b) < 0:
            a = c

        print(f"Iteration: {i}, a: {a}, b: {b}, c: {c}, f(c): {f(c)}")
        i += 1

    return c

print(bisection_method("x**3 - 4*x**2 - 10", 0, 1, 0.0001))

"""# Regula Falsi

"""

def regula_falsi_method(func, a, b, tol):

    def f(x):
        f = eval(func)
        return f

    i = 1
    while True:

        # regula falsi formula
        c = (a * f(b) - b * f(a)) / ((f(b) - f(a)))

        if f(c) == 0:
            return c

        elif f(c) * f(a) < 0:
            if abs(c - b) < tol:
                return c
            b = c

        elif f(c) * f(b) < 0:
            if abs(c - a) < tol:
                return c
            a = c

        elif f(a) * f(c) > 0 and f(b) * f(c) > 0:
            print("ERROR: No roots exist")
            return

        print(f"Iteration: {i}, a: {a}, b: {b}, c: {c}, f(c): {f(c)}")
        i += 1



print(regula_falsi_method("math.cos(x) - x", 0, 1, 0.0001))

"""

```
# This is formatted as code
```

# Newtons Method"""

import numpy as np

def newtons_method(f, df, x0, tolerance=1e-6, max_iterations=100):

    x = x0
    for iteration in range(1, max_iterations):

        # newtons method formula
        x_new = x - (f(x)/df(x))
        if (abs(x_new - x) < tolerance):
            return x_new, iteration
        print(f"Iteration : {iteration}, x_new: {x_new}, f(x): {f(x)}")
        x = x_new

    return x, iteration

def f(x):
    return -x**3 - np.cos(x)

def df(x):
    return -3*x**2 + np.sin(x)

root, iterations = newtons_method(f, df, -1.0, 1e-10, 100)

"""# Gaussian Elimination"""

def gaussian_elimination(a_matrix, b_matrix):

    if a_matrix.shape[0] != a_matrix.shape[1]:
        print("ERROR: Square matrix not given!")
        return

    if b_matrix.shape[0] != a_matrix.shape[0]:
        print("ERROR: Constant vector incorrectly sized!")
        return

    n = len(b_matrix)
    m = n - 1

    # Applying Gauss Elimination
    for i in range(0, m):
        if a_matrix[i][i] == 0:
            print("Division by zero error")
            return

        for j in range(i + 1, n):
            scaling_factor = a_matrix[j][i] / a_matrix[i][i]
            a_matrix[j] = a_matrix[j] - (scaling_factor * a_matrix[i])
            b_matrix[j] = b_matrix[j] - (scaling_factor * b_matrix[i])
            print(f"A: \n{a_matrix}, \nb: \n{b_matrix}, \n\n") # For visualization

    # Backward substitution
    b_matrix[m] = b_matrix[m] / a_matrix[m][m]

    for k in range(n-2, -1, -1):
        b_matrix[k] = (b_matrix[k] - np.dot(a_matrix[k, k+1:n], b_matrix[k+1:n]))/a_matrix[k,k]

    return b_matrix


A = np.array([[4.0, -2.0, 1.0], [-2.0, 4.0, -2.0], [1.0, -2.0, 4.0]])
b = np.array([11.0, -16.0, 17.0])

x = gaussian_elimination(A, b)
print("x1,  x2,  x3")
print(x)

"""# LU Decomposition"""

def LU_Decomposition(A):
    if A.shape[0] != A.shape[1]:
        print("ERROR: Not a square matrix!")
        return
    U = A.copy()
    n = A.shape[0]
    L = np.eye(n, dtype=np.double)

    for i in range(n):
        for j in range(i+1, n):
            scaling_factor = U[j, i]/U[i, i]
            L[j, i] = scaling_factor
            U[j] = U[j] - (scaling_factor * U[i])
    return L, U

A = np.array([[ 1,  1,  0],
       [ 2,  1, -1],
       [ 3, -1, -1]],dtype=np.double)

L, U = LU_Decomposition(A)
print(L)
print(U)

"""# Trapezoidal Rule

"""

import math

def trapezoidal_rule(f, a, b, n):
    h = (b - a) / n
    s = (f(a) + f(b))

    for i in range(1, n):
        s += 2*f(a + i*h)

    return s * (h / 2)

def f(x):
  return  math.sin(x)

a = 0
b = math.pi/2
n = 10

result = trapezoidal_rule(f, a, b, n)
print(result)

"""# Simpson's 1/3rd Rule"""

def simpsons_1_3rd_rule(f, a, b, n):
    h = (b - a)/n
    s = f(a) + f(b)

    for i in range(1, n):


        if i%2 == 0:
            s += 2*f(a + h*i)
        else:
            s += 4*f(a + h*i)

    return (h / 3) * s

def f(x):
    return math.sin(x)

a = 0
b = math.pi/2
n = 100

simpsons_1_3rd_rule(f, a, b, n)

"""# Simpson's 3/8th rule"""

def simpsons_3_8th_rule(f, a, b, n):

    # Simpsons 3/8th rule
    h = (b - a)/n
    s = (f(a) + f(b))

    for i in range(1, n):

        if i % 3 == 0:
            s += 2*f(a + h*i)

        else:
            s += 3*f(a + h*i)

    return (h * 3/8) * s

def f(x):
    return math.sin(x)

a = 0
b = math.pi/2
n = 10000


simpsons_3_8th_rule(f, a, b, n)

"""# Eulers Method

"""

def eulers_method(f, y0, x0, x_end, h):

    # Initialize the solution
    x = np.arange(x0, x_end + h, h)
    y = np.zeros(len(x))

    y[0] = y0

    # Euler's Method
    for i in range(1, len(x)):
        y[i] = y[i - 1] + h*f(x[i - 1], y[i - 1])

    return x, y

def f(x, y):
    return -2*x - y

y0 = -1
x0 = 0
x_end = 5
h = 0.1

x, y = eulers_method(f, y0, x0, x_end, h)
i = 1
for xx, yy in zip(x, y):
    print(f"x{i} = {xx:.3f}, y{i} = {yy:.3f}")
    i += 1

"""# Runge Kutta 4th Order Method"""

def RK_4(f, y0, x0, x_end, h):

    # Initialize the solution
    x = np.arange(x0, x_end + h, h)
    y = np.zeros(len(x))


    y[0] = y0

    # Runge Kutta Method
    for i in range(1, len(x)):
        xi = x[i - 1]
        yi = y[i - 1]
        k1 = h*f(xi, yi)
        k2 = h*f(xi + h/2, yi + k1/2)
        k3 = h*f(xi + h/2, yi + k2/2)
        k4 = h*f(xi + h, yi + k3)

        k = (k1 + 2*k2 + 2*k3 + k4)/6
        # print(k)
        y[i] = yi + k
    return x, y

def f(x, y):
    return np.sin(x) - y

y0 = 0
x0 = 0
x_end = 10
h = 0.1

x, y = RK_4(f, y0, x0, x_end, h)
i = 1
for xx, yy in zip(x, y):
    print(f"x{i} = {xx:.5f}, y{i} = {yy:.5f}")
    i += 1

"""# Power Method

"""

def power_method(A, x=[1,0,0],iterations = 100, tol =1e-5):
    for i in range(iterations):

        y = np.dot(A, x)
        eigen_value = np.max(np.abs(y))

        x = y / eigen_value

        if np.linalg.norm(np.dot(A, x) - eigen_value * x) < tol:
            break

    return eigen_value, x

A = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]])
power_method(A)

"""# QR Decomposition

"""

import numpy as np


def QR_decomposition(A):

    m, n = A.shape

    Q = np.zeros((m, n))

    for i, column in enumerate(A.T):
        Q[:, i] = column

        for prev in Q.T[:i]:
            Q[:, i] -= (prev @ column)/(prev @ prev) * prev

    Q /= np.linalg.norm(Q, axis=0)
    R = Q.T @ A

    return Q, R

A = np.array([[1, -1, 4],
              [1, 4, -2],
              [1, 4, 2],
              [1, -1, 0]],dtype=float)
QR_decomposition(A)